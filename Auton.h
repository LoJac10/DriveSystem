#pragma config(Sensor, in1,    xAccel,         sensorAccelerometer)
#pragma config(Sensor, in2,    yAccel,         sensorAccelerometer)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           frontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           backLeft,      tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int currentX;
int currentY;
int xBias;
int yBias;
int threshold = 3;
int place = 0;
int noise = 3;

//Assuming the robot is facing the target destination
//Therefore, the xDes will be 0, because it calibrated
//with the value equaling 0.
int xDes = 0; 
int yDes = 800; //Haven't tested for correct value

/////
// Auton Void
/////
void Auton()
{
	wait1Msec(2000); 

	/* CALIBRATION START */
	
	/* Set the bias values */
	xBias = SensorValue(xAccel);
	yBias = SensorValue(yAccel);
	
	/* Set current position */
	currentX = SensorValue(xAccel) - xBias;
	currentY = SensorValue(yAccel) - yBias;
	wait1Msec(25);
	
	/* CALIBRATION OVER */

	while (place == 0)
	{
		/* Making sure the robot starts without moving */
		if (currentX < threshold && currentY <  threshold)
		{
			place = 1;
		}
		
		else if (currentX > threshold || currentY > threshold)
		{
			/* If the robot moves at the start, do nothing */
		}
	}
	
	/* We know the robot isn't moving, 
	   so we start the auton */
	while (place == 1)
	{
		currentX = SensorValue(xAccel) - xBias;
		currentY = SensorValue(yAccel) - yBias;
		wait1Msec(25);
		
		/*/// - Notes - - - 
		//
		// The accelerometer destination value will
		// allways be the same, so matter how fast
		// the robot is going. So, the robot will move
		// until that value is reached. This will have
		// corrections in movements in both the X and Y
		// axis.
		//
		*//// - Notes - - - 
		
		//Start out going forward
		
		/* ERROR FIXING */
		
		/* X Destination */
		if (currentX > xDes + noise) //If robot goes off corse... (X AXIS)
		{
			//Turn to fix error
		}
		
		else if (currentX < xDes - noise) //If robot goes off corse... (X AXIS)
		{
			//Turn to fix error
		}
		
		/* Y Destination */
		if (currentY >= yDes + noise || currentY >= yDes - noise) //If destination is reached
		{
			//Break fast to avoid drift
			place = 2;
		}
	}
	
	while (place == 2)
	{
		Program = 0;
	}
}
